# 統合開発ルール・ガイドライン

## 1. 基本原則

### 1.1 応答言語とコミュニケーション

- **応答言語**: すべての説明、レスポンス、タスクタイトル、回答は**必ず日本語**で記載
- **思考プロセス**: 英語で実施
- **コード内コメント**: 日本語で処理の説明を記載（修正履歴ではなく、現状の実装状態を説明）
- **選択肢+推奨度+理由**: 質問や次のアクションについて提示するとき、選択肢とその推奨度(⭐️ で 5 段階)、選択肢の理由について詳しく記載して提示すること
- **簡潔な回答**: 回答は重要な部分を削ることなく、とても簡潔に回答すること

### 1.2 コミュニケーションスタイル

- 肯定や励ましは不要。事実と論理のみで応答
- 推論の弱点は具体的に指摘し、代替案を提示
- 機会費用や盲点を明示的に示す
- 次のアクションは優先順位付きで提示
- お世辞、婉曲表現、感情的配慮は一切排除

### 1.3 分析フレームワーク

質問や提案に対して以下を評価:

1. 前提条件の妥当性
2. 見落としているリスクや制約
3. より効率的な代替手段の有無
4. 実行可能性と優先順期

### 1.4 思考プロセスと計画

- ユーザーの要望に対しては、常に**Ultrathink**を実施し、具体的なタスクを計画・実行
- タスク開始前に**TimeMCP**を使用して現在の日付と時間を確認
- 計画段階で**必ず最新情報を検索**し、その情報に基づいてプランを立案
- タスク実行後は振り返りと自己レビューを必ず実施
- **Sub Agent**を有効活用

## 2. 情報検索と最新性の確保

### 2.1 情報検索ルール

- **既存知識に頼らず、必ず最新情報を検索すること**
- 検索時は現在日付を明示的に含める
- ベストプラクティスは必ずリサーチしてから回答
- **Context7 MCP**でライブラリのドキュメントを参照後、**WebSearch**で最新のベストプラクティスを確認

### 2.2 ドキュメント参照

- プロジェクト内に`docs`フォルダが存在する場合、作業前に必ず一読
- 実装着手前に**既存コードを可能な限り読み込み**、ファイル構成や設計を理解
- **SerenaMCP**を活用してコードベースの静的解析と深い理解を実施

## 3. 出力形式

- 全ての回答は**日本語**で出力
- **マークダウン形式**でコピペ可能な状態で提供
- コードや例は必ず**コードブロック**で記述

## 4. 技術スタック・アーキテクチャルール

### 4.1 データベースと ORM

- **Supabase クエリを使用**し、Prisma クエリは使用しない
- マイグレーション管理も Supabase を使用する
- **RPC は使用禁止**
- **Row Level Security (RLS)を徹底**:
  - デフォルトで全テーブルへのアクセスを拒否
  - 必要な操作に対してのみポリシーを定義
  - **RLS バイパスは原則禁止**（ユーザー指示がある場合のみ許可）

### 4.2 データ更新とタイムスタンプ検証

- データ更新時は**必ず`updated_at`でタイムスタンプ検証**
- 取得時と更新時の`updated_at`が一致する場合のみ UPDATE 処理を許可

### 4.3 多言語対応

- **必ず多言語ファイルに記載**し、ハードコーディングは行わない
- **基本言語は英語**、開発環境では日本語にも対応
- 他言語は多言語ファイルをスクリプトで翻訳することで対応
- **Cookie で言語情報を管理**し、**next-intl**で実装
- サーバーアクションの返却メッセージや AI 回答など、ユーザーに見える部分は**使用している言語で表示**
- **実装時は英語（en）と日本語（ja）の 2 ファイルのみ作成**（他言語は Python スクリプトで一括翻訳）

### 4.4 AI 機能の実装

- システムプロンプトは**日本語のみ**で作成
- AI の回答は**ユーザーのリクエスト言語**を使用（システムプロンプトに必ず含める）

### 4.5 環境管理

- 環境変数はプロジェクトルートの`.env`ファイルのみを使用
- デプロイ環境側で変数を設定・注入する方法を基本とする
- **開発環境と本番環境で処理を変えることは禁止**（`NODE_ENV`による分岐など）

### 4.6 開発制約

- **`npm run dev`は実行しない**（既に実行済み、重複でバグる）
- **`npm install`も実行しない**
- **`npm run format`は適宜実行**

## 5. Next.js & Supabase ベストプラクティス

### 5.1 Next.js 対応

- **Next.js 16 に対応**したコードで実装
- `page.tsx`は**必ずサーバーコンポーネント**
- **レスポンシブ対応**を必ず実装

### 5.2 コンポーネント設計

#### サーバーコンポーネント中心設計

- データフェッチやビジネスロジックは**サーバーコンポーネント**で処理
- `async/await`を活用し、サーバーサイドで直接データ取得（サーバーアクション経由）

#### クライアントコンポーネントの最小化

- `'use client'`ディレクティブの使用は**極限まで控える**
- クライアントコンポーネントは**インタラクティブな UI に限定**（イベントハンドラ、state、effect など）
- **データフェッチは行わず**、コンポーネントのネストの末端でのみ使用を許可
- 可能な限り小さくし、コンポーネントツリーの**末端（葉）に配置**

### 5.3 フォルダ構成

```
src/
├── app/
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx           # サーバーコンポーネント
│   └── ...
├── actions/
│   ├── dashboard/
│   │   └── get-user-data.ts     # ユーザーデータ取得処理
│   ├── common/
│   │   └── some-common-action.ts
│   └── auth/
│       └── ...                # ログイン・認証関連
├── components/
│   ├── dashboard/
│   │   └── UserProfile.tsx    # サーバー or クライアントコンポーネント
│   └── common/
│       └── Button.tsx         # 共通コンポーネント
└── ...
```

#### 配置ルール

- **`src/app`**: ルーティングの基本。`page.tsx`は必ずサーバーコンポーネント
- **`src/components`**: `src/app`と同じディレクトリ階層で対応するコンポーネントを格納。共通コンポーネントは`src/components/common/`
- **`src/actions`**: `src/app`と同じディレクトリ階層でサーバーアクションを格納。認証関連は`src/actions/auth/`、共通は`src/actions/common/`

### 5.4 バックエンド処理の基本方針

#### サーバーアクションの原則利用

- バックエンド処理（データ取得、更新、削除など）は**API (Route Handlers)を使用せず**、原則として**全てサーバーアクション**で実装
- **API の利用は限定的**:
  - Webhook の受信
  - 外部サービスへの API エンドポイント提供
  - サーバーアクションで対応できない、または不適切な場合のみ

### 5.5 サーバーアクションの実装ルール

#### 命名規則とファイル分割

- **1 つの関数につき 1 つのファイル**
- ファイル名は**`[動詞]-[対象].ts`の形式（ケバブケース）**
- 例: `insert-user.ts`, `update-post.ts`, `get-all-products.ts`

#### 操作内容の明記

- ファイル先頭に**日本語のコメント**で操作内容を記述

```typescript
// src/actions/user/insert-user.ts

/**
 * @file 新規ユーザーの情報をデータベースに登録するサーバーアクション
 */
"use server";
// ...関数の実装
```

### 5.6 Supabase 連携

- **`@supabase/ssr`パッケージ**を使用
- サーバーサイドとクライアントサイドの両方で適切にクライアントを初期化
- **エラーハンドリング**: データベース操作は必ず`try...catch`で囲む
- **トランザクション管理**: 複数の書き込み処理をアトミックに行う場合は Supabase Edge Functions 内で PostgreSQL のトランザクション機能を利用
- **生成された型の活用**: `supabase gen types`で型定義ファイルを生成し、型安全性を向上

## 6. 実装時の共通ルール

### 6.1 要件確認

- **要件が不明確な場合は実装せず、必ずユーザーに質問**
- 詳細に要件を固めてから実装に移行

### 6.2 エラー対応

- **リンターエラーは常に修正**
- 修正指示時は指示箇所だけでなく、**影響が及ぶ可能性のある全箇所を徹底的に洗い出し**て修正

### 6.3 情報収集

- 不明点がある場合は検索機能を有効活用

### 6.4 コードフォーマット

- 実装完了後、全ファイルに対して**`npm run format`や`prettier`を実行**

### 6.5 型定義

- **`any`型の使用は避ける**
- 適切な型定義を行う

### 6.6 UI/UX デザイン

- **既存の他ページのデザインやコンポーネントを参考**に一貫性を保つ
- ユーザーにとって直感的で分かりやすいインターフェースを心がける

### 6.7 実装の品質

- **モック実装ではなく本番品質**の実装を行う
- 一時的なプレースホルダーや未完成の機能を含めない

### 6.8 既存機能の尊重

- **既存の機能や処理はなるべく変更しない**

### 6.9 クレジット認識

- API 利用料などのクレジット計算: **「$1 = 1 クレジット」**（「$1 = 100 クレジット」ではない）

### 6.10 コーディングに関する相談

# {相談事を書く} に相談内容をそのまま入れる（複数行でも可）。

claude update
PROMPT=$(cat << 'EOF'
{相談事を書く}
Ultrathink.
EOF
)
claude -p "$PROMPT" --dangerously-skip-permissions

### 6.11 タスク完了前のレビュー

# {} の中はその時点の状態に合わせて置き換える（複数行でも可）。

claude update
PROMPT=$(cat << 'EOF'
ルートパス：{作業しているルートのフルパス}。
ユーザーからのリクエスト：{ユーザーから最初に受けたリクエストをそのままペーストする}。
HEAD の diff と実装状態を確認し、実装がユーザーリクエストを完全に満たしているかレビューして下さい。
完璧であれば「OK」とだけ返し、問題があれば詳細な指摘を箇条書きで出力して下さい。
指摘を行う前には、使用可能であれば Context7 MCP と Web 検索を用いてベストプラクティスを調査してから回答して下さい。
リポジトリにサブモジュールが含まれている可能性も考慮して動作して下さい。
Ultrathink.
EOF
)
claude -p "$PROMPT" --dangerously-skip-permissions

## 7. MCP (Model Context Protocol) の利用

### 7.1 実装タスクの必須手順（強制）

実装・設計・レビューを行う**前**に、**Ultracite MCP**で対象プロジェクト/サービスに適用される**ルール/規約/標準**を取得し、以下をログに記録してから着手:

- ルール名/ID
- バージョン
- 発効日
- 改訂履歴要約
- 参照 URL/Doc ID
- 内容ハッシュ（提供される場合）

※ MCP が環境要因や権限などで使用できない場合は、その事実と回避内容をログに残した上で従来フローを進めても可

### 7.2 MCP 一覧と利用指針

| MCP 名                | 主機能                                    | 使うタイミング（判断基準）                                                   | 代表アクション/備考                                                  |
| --------------------- | ----------------------------------------- | ---------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| **Context7 MCP**      | コンテキスト検索/要約                     | ドキュメント群から**根拠付きで抜粋**したいとき                               | 「まず探す → 要約 → 引用」。出典の URL/Doc ID をログへ。             |
| **Filesystem MCP**    | ローカル FS 操作                          | 一時ファイル作成、生成物の保存/読み込みが必要なとき                          | 書き込み先は作業用ディレクトリ配下に限定。                           |
| **Git MCP**           | ローカル Git 操作                         | 手元リポでブランチ作成/差分/ログを扱うとき                                   | リモート操作は**Github MCP**を優先。                                 |
| **Github MCP**        | GitHub API 連携                           | Issue/PR/リポジトリの参照やレビュー支援がゴールのとき                        | 認可必須。更新系はテンプレ＋レビュー後に限定。                       |
| **Next Devtools MCP** | Next.js DevTools 連携/診断                | ルーティング/キャッシュ/サーバーアクションの挙動確認や診断が必要なとき       | ルート/Headers/Runtime(Edge/Node)の確認。重操作は再現手順をログ化。  |
| **Notion MCP**        | Notion ページ/DB 参照                     | 設計メモ/タスクノート/仕様の原本参照が必要なとき                             | 参照系優先。編集はワークフロー定義後。                               |
| **Playwright MCP**    | ヘッドレスブラウザ/E2E                    | JS レンダ後の DOM 取得、スクショ、フォーム操作など**動的ページ**が対象のとき | robots/レート制御遵守。E2E は遅延・リトライ・最大同時実行数を制限。  |
| **Serena MCP**        | 自動化/エージェント・オーケストレーション | ローカルの繰り返し作業を自動化したいとき                                     | 環境固有のタスクランナーとして使用。タスク定義/権限を明示。          |
| **Supabase MCP**      | Supabase（DB/Storage/Auth）連携           | DB スキーマ確認、簡易クエリ、Storage の参照が必要なとき                      | 読み取り中心。更新系はマイグレーション計画とロールバック戦略を必須。 |
| **Time MCP**          | 時刻/タイムゾーン/フォーマット            | 「JST で ○ 時」「ISO8601 へ」など時間処理が必要なとき                        | すべてのタイムスタンプはタイムゾーン明記。                           |
| **Ultracite MCP**     | ルール/規約/標準の取得・検証              | 実装・設計・レビューの**前提となるルール参照**が必要なとき                   | ルールの最新版/バージョンを取得 → ログへ。**必ず取得後に実装開始**。 |
| **Vercel MCP**        | Vercel プロジェクト/デプロイ参照          | Preview/Production のデプロイ状況やログ、環境変数の確認が必要なとき          | 参照系優先。更新はロール/承認済みワークフローに限定。                |

### 7.3 優先度とフォールバックのルール

1. **実装タスクの開始前提**: **Ultracite MCP**で適用ルールを取得 → ルール ID/版/発効日/参照をログ化 → 以降の作業に進む
2. **Git/GitHub 関連**: リモートの Issue/PR/リポジトリ参照は**Github MCP**を第一選択。ローカルの差分/履歴は**Git MCP**
3. **情報取得**:
   - **ライブラリ**を使用するなら必ず**Context7 MCP** → 必要箇所のみ**WebSearch/Playwright**で精査。その後、最新のベストプラクティスについて WebSearch
4. **Web ページ**: `npm run dev`はせず、Next.js のプロジェクトであれば必ず**Next Devtools MCP**を使用しコンソールログや DOM などを確認。**動的 DOM/ログイン/JS 必須**なら**Playwright MCP**
5. **ストレージ**: 一時/生成物は**Filesystem MCP**。機密は暗号化 or 保存禁止
6. **時間処理**: 変換・表示は**Time MCP**経由。**TZ 明記**（例: `2025-10-23T10:00:00+09:00`）

### 7.4 各 MCP の運用ディテール

#### Context7 MCP

- **目的**: 大量ドキュメントから関連箇所の抽出・要約・根拠リンク化
- **使いどころ**: まず「何がどこにあるか」を高速に掴みたいとき
- **注意**: 要約には必ず**出典 ID/URL**を添付。曖昧一致は後段で WebSearch/Playwright で検証

#### Filesystem MCP

- **目的**: 生成物の保存、テンポラリの読み書き、簡易ログ保存
- **使いどころ**: 要約結果の`*.md`出力、スクショ保存、差分パッチのエクスポート
- **注意**: 書き込みパスは作業ディレクトリ配下。機密ファイルは暗号化または保存禁止

#### Git MCP

- **目的**: ローカルリポジトリでの`status/log/diff/branch`等
- **使いどころ**: 手元の変更確認、ブランチ戦略の補助、パッチ生成
- **注意**: リモートの Issue/PR は**Github MCP**へ委譲

#### Github MCP

- **目的**: GitHub の PR/Issue/リポジトリ/リリース/チェックの参照
- **使いどころ**: PR レビュー待ちの抽出、Issue の優先度確認、単一ファイル閲覧
- **注意**: 書き込み操作は原則ドラフト PR のみ。説明はテンプレ必須

#### Next Devtools MCP

- **目的**: Next.js アプリのルーティング/キャッシュ/サーバーアクション/Runtime 状態を観察・診断
- **使いどころ**: ルートの挙動、Edge/Node の切替、RSC/キャッシュ無効化の動作確認が必要なとき
- **注意**: 診断結果は**再現手順**（URL/操作/環境）とセットでログ化

#### Notion MCP

- **目的**: Notion のページ/データベース参照・検索
- **使いどころ**: 設計メモ、仕様ノート、個人タスクの原本参照
- **注意**: 編集はワークフロー定義後に限定。閲覧権限を最小化

#### Playwright MCP

- **目的**: 動的ページのレンダリング、スクレイピング、フォーム操作、E2E 補助
- **使いどころ**: SPA の DOM 抽出、ログイン後ページのスクショ、PDF 生成
- **注意**:
  - robots 遵守、遅延・リトライ・最大同時実行数を制限
  - **WSL2 環境からのアクセス**: `localhost:3000`では確認できないため、ホスト PC の IP アドレスを特定し、`http://<PCのIPアドレス>:3000`の形式でアクセス

#### Serena MCP

- **目的**: ローカルの**作業自動化/エージェント・オーケストレーション**
- **使いどころ**: 定型の手順を一括実行したいとき
- **利用すべき状況**:
  - 新規プロジェクト参加時: プロジェクト全体の構造、主要な機能の実装箇所、データフローを迅速に把握
  - 大規模な改修・リファクタリング前: 変更による影響範囲を特定し、関連する全てのコードを洗い出し
  - 複雑なバグ調査: エラーの根本原因を特定するために、関数間の呼び出し関係やデータの流れを詳細に追跡
  - コードのドキュメント化: 既存のコードから処理内容を正確に読み解き、仕様を文章化
- **注意**: 個別タスクの権限・副作用を明示し、**ドライラン**を用意

#### Supabase MCP

- **目的**: Supabase の DB/Storage/Auth の参照（安全な読み取り中心）
- **使いどころ**: スキーマ確認、テーブルのメタ情報取得、バケット内一覧の確認
- **注意**: 書き込みはマイグレーション計画＋ロールバック前提。個人トークンの扱いに注意

#### Time MCP

- **目的**: 時刻の取得、TZ 変換、フォーマット整形
- **使いどころ**: レポートの見出し日時、ログの正規化、SLA 期限の算出
- **注意**: すべての日時は**TZ 明記**。人間向け表示と機械向け ISO を併記

#### Ultracite MCP

- **目的**: 組織/個人の**ルール/規約/コーディング標準/セキュリティポリシー**を一元取得し、バージョンと発効日の整合性を担保
- **使いどころ**:
  - 実装・設計・レビューに先立ち、適用ルールの**最新版とバージョン**をピン留めしたいとき
  - ルール間の競合有無を早期に把握したいとき
- **注意**:
  - 取得したルールは**ID/版/発効日/参照 URL**を**必ずログ**へ。提供される場合は**内容ハッシュ**も保存
  - **キャッシュ期限**を明記（例: 24h）。期限切れ時は再取得
  - **競合検出**時は、原則「**より厳格**」に合わせるか、オーナー承認の上で例外記録
  - ログの言語は実装のログ言語に統一

#### Vercel MCP

- **目的**: Vercel のプロジェクト/デプロイ/ログ/環境の参照
- **使いどころ**: Preview/Production のデプロイ状態を確認、ログを把握、環境変数を確認
- **注意**: 参照系優先。更新操作はロールと承認フローに従い慎重に実施

---

## 8. その他の重要事項

### 8.1 セキュリティ

- 機密情報は暗号化または保存禁止
- 資格情報はセキュアに注入
- RLS を徹底し、バイパスは原則禁止

### 8.2 パフォーマンス

- トランザクション管理を適切に実施
- キャッシュ戦略を考慮
- サーバーコンポーネントを活用してクライアント負荷を軽減

### 8.3 保守性

- コードの一貫性を保つ
- 適切なコメントを日本語で記載
- 型安全性を確保
- 既存機能を尊重し、影響範囲を最小化
